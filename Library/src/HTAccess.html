<HTML>
<HEAD>
  <!-- Changed by: Henrik Frystyk Nielsen, 15-Jul-1996 -->
  <TITLE>W3C Sample Code Library libwww Accessing URLs</TITLE>
</HEAD>
<BODY>
<H1>
  Accessing URLs
</H1>
<PRE>
/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/
</PRE>
<P>
This module is the application interface module to the
<A HREF="HTReq.html">Request class</A>. It contains a lot of methods for
loading URLs and also for uploading URLs using <CODE>PUT</CODE> or
<CODE>POST</CODE>, for example. You can use the Request class directly but
this module makes it easier to use by providing a lot of small request functions
using the Request class in different ways. It contains help functions for
accessing documents and for uploading documents to a remote server.
<P>
This module is implemented by <A HREF="HTAccess.c">HTAccess.c</A>, and it
is a part of the <A HREF="http://www.w3.org/Library/"> W3C Sample Code
Library</A>.
<PRE>
#ifndef HTACCESS_H
#define HTACCESS_H

#include "HTReq.h"
#include "HTAnchor.h"
</PRE>
<H2>
  Load a Document (Method = GET)
</H2>
<P>
URLs can be accesses using a character string, for example
"<CODE>http://www.w3.org</CODE>" or it can be accessed by using the libwww
representation of a URL called an <A HREF="HTAnchor.html">Anchor object</A>.
Note that we call all objects accessible through URLs for <I>documents</I>
- this is a notion we have inherited from the hypertext world.
<H3>
  Load a Document from Absolute URL
</H3>
<P>
Request a document referencd by an <I>absolute</I> URL. The output from the
request is passed to the <A HREF="HTFormat.html">Stream Pipe Manager</A>
that figures out where to pump the data. This can for example be to the display
or to a local file depending on the set of
<A HREF="HTFormat.html#type">converters</A> registered by the application.
<PRE>extern BOOL HTLoadAbsolute (const char * url, HTRequest * request);
</PRE>
<H3>
  Load a Document from Relative URL
</H3>
<P>
Request a document referenced by a <I>relative</I> URL. The relative URL
is made absolute by resolving it relative to the address of the '<I>base</I>'
anchor.
<PRE>extern BOOL HTLoadRelative (const char * 	relative,
			    HTParentAnchor *	base,
			    HTRequest *		request);
</PRE>
<H3>
  Load a Document into Memory
</H3>
<P>
Request a document referred to by the URL and load it into a chunk object.
A <A HREF="HTChunk.html">chunk object</A> is a dynamic string so in the end
you will have a single memory buffer containing the document.
<PRE>extern HTChunk * HTLoadToChunk (const char * url, HTRequest * request);
</PRE>
<H3>
  Load a Document and Save as a Local File
</H3>
<P>
This function loads a URL and saves the contents in the specifed file. The
file should not &nbsp;be open, as the load function both opens and closes
the file. If the file already exists then it asks the user whether the file
should be overwritten or not. the contents is saved <I>ASIS</I> - that is
- we do not touch the contents of the file!
<PRE>
extern BOOL HTLoadToFile (const char * url, HTRequest * request,
			  const char * filename);
</PRE>
<H3>
  Load a Document and put the Contents into a Stream
</H3>
<P>
Request a document referenced by an absolute URL and sending the data down
a stream. This stream can be anny stream you like, for eample one from the
<A HREF="WWWStream.html">Stream Interface</A>.
<PRE>
extern BOOL HTLoadToStream (const char * url, HTStream * output,
			    HTRequest * request);
</PRE>
<H3>
  Load a Document using an Anchor
</H3>
<P>
Here the URL is represented by an <A HREF="HTAnchor.html">Anchor object</A>.
You can get an anchor object representing a URL by passing the URL to the
appropriate method in the <A HREF="HTAnchor.html">Anchor class</A>.
<PRE>extern BOOL HTLoadAnchor (HTAnchor * anchor, HTRequest * request);
</PRE>
<H3>
  Load a Document into Memory using an Anchor
</H3>
<P>
This is the same as <CODE>HTLoadToChunk</CODE> but instead of passing a URL
string you pass an anchor object. Internally, all URLs are represented as
anchors which contains all the information we have about the resource.
<PRE>extern HTChunk * HTLoadAnchorToChunk (HTAnchor * anchor, HTRequest * request);
</PRE>
<H3>
  Recursively Request a Document using Anchors
</H3>
<P>
Same as <CODE>HTLoadAnchor()</CODE> but the information in the
<A HREF="HTReq.html#Error">error stack</A> in the <A HREF="HTReq.html">request
object</A> is kept, so that any error messages in one. This function is almost
identical to <CODE>HTLoadAnchor</CODE>, but it doesn't clear the error stack
so that the information in there is kept.
<PRE>extern BOOL HTLoadAnchorRecursive (HTAnchor * anchor, HTRequest * request);
</PRE>
<H2>
  Load Special Documents
</H2>
<P>
We also have a set of functions for loading special files like rules files
which also are referenced by a URL but which do have to be treated specially.
<H3>
  Load a Rule File
</H3>
<P>
Rule files can be loaded just like any other URL but yuou can also just use
this function which does all the work for you :-) It loads a rule find with
the URL specified and add the set of rules to the existing set.
<PRE>extern BOOL HTLoadRules (const char * url);
</PRE>
<H2>
  Search a Document (Method = GET)
</H2>
<P>
The search methods all use <CODE>GET</CODE> as the method in the
<A HREF="http://www.w3.org/Protocols/">HTTP request</A>. The functions
take the keywords and encode them according to
<A HREF="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1866.txt">RFC
1866 (Hypertext Markup language)</A>. That is, the query part is separated
from the rest of the URL by a "?" nu is treated as being part of the URL
path.
<P>
The keywords are passed to the function as a <A HREF="HTChunk.html">Chunk
Object</A> and each keyword <B>must</B> be separated by a space ' '. This
will then be converted into a '+' before added to the URL.
<H3>
  Search a Document from Absolute URL
</H3>
<PRE>
extern BOOL HTSearchAbsolute (HTChunk *		keywords,
			      const char *	base,
			      HTRequest *	request);
</PRE>
<H3>
  Search a Document from Relative URL
</H3>
<P>
Search a document referenced by a <I>relative</I> URL. The relative URL is
made absolute by resolving it relative to the address of the '<I>base</I>'
anchor.
<PRE>
extern BOOL HTSearchRelative (HTChunk *		keywords,
			      const char * 	relative,
			      HTParentAnchor *	base,
			      HTRequest *	request);
</PRE>
<H3>
  Search a Document using an Anchor
</H3>
<PRE>
extern BOOL HTSearchAnchor (HTChunk *		keywords,
			    HTAnchor *		anchor,
			    HTRequest * 	request);
</PRE>
<H3>
  Search a Document using an Anchor Using a String
</H3>
<P>
This works exactly as the <CODE>HTSearchAnchor()</CODE> function but takes
a C string instead of a <A HREF="HTChunk.html">chunk object</A>.
<PRE>
extern BOOL HTSearchString (const char *	keywords,
			    HTAnchor *		anchor,
			    HTRequest * 	request);
</PRE>
<H2>
  Handle Forms Using GET Method
</H2>
<P>
Form data can be sent to a HTTP server in two ways - it can either use a
<CODE>GET</CODE> method or it can use a <CODE>POST</CODE> method. The difference
is whether the request "has side effects" or not. For example, if you are
ordering a pizza then the (hopefully positive) sideeffect is that you actually
get one delivered. However, if you are issuing search data - for example
to Alta Vista, then there is no sideeffect. In the former example you would
use the <CODE>GET</CODE> form and in the latter you would use the
<CODE>POST</CODE> form.
<H3>
  Send a Form from Absolute URL using GET
</H3>
<P>
Request a <CODE>GET</CODE> form referencd by an absolute URL appended with
the formdata given. The URL can <I>NOT</I> contain any fragment
identifier!&nbsp;The list of form data must be given as an
<A HREF="HTAssoc.html">association list</A> where the name is the field name
and the value is the value of the field. Enter the fields in the same order
as they are setup in the HTML file, the it will work.
<PRE>
extern BOOL HTGetFormAbsolute (HTAssocList *	formdata,
			       const char *	base,
			       HTRequest *	request);
</PRE>
<H3>
  Send a Form from Relative URL using GET
</H3>
<P>
Request a <CODE>GET</CODE> form referencd by a relative URL appended with
the formdata given. The list of formdata must be given as an
<A HREF="HTAssoc.html">association list</A> where the name is the field name
and the value is the value of the field.
<PRE>
extern BOOL HTGetFormRelative (HTAssocList * 	formdata,
			       const char * 	relative,
			       HTParentAnchor *	base,
			       HTRequest *	request);
</PRE>
<H3>
  Send a Form using an Anchor and the GET Method
</H3>
<P>
Request a <CODE>GET</CODE> form referencd by an anchor object appended with
the formdata given. The URL can <I>NOT</I> contain any fragment identifier!
The list of form data must be given as an association list where the name
is the field name and the value is the value of the field.
<PRE>
extern BOOL HTGetFormAnchor (HTAssocList *	formdata,
			     HTAnchor *		anchor,
			     HTRequest * 	request);
</PRE>
<H2>
  Handle Forms Using POST Method
</H2>
<P>
The main difference between a <CODE>GET</CODE> form and a <CODE>POST</CODE>
form is that the data in a <CODE>POST</CODE> form is sent as the body part
of the <A HREF="http://www.w3.org/Protocols/">HTTP</A> message whereas
a <CODE>GET</CODE> form wraps it all up into the URL. In order to be able
to use the <CODE>POST</CODE> data object at a later point in time, we create
a new anchor on the fly. This anchor has a URL file location which points
into the temporary area given by the <A HREF="HTUser.html">User Profile
Object</A>. That is - you can actually save the anchor using a
<CODE>PUT</CODE> request and then be able to retrive the form data at a later
point in time. Even though this may seem "ambitious" for posting form data,
it is really just a special example of sending any kind of data to a remote
server. All <CODE>POST</CODE> form functions return the new anchor or
<CODE>NULL</CODE> if they fail.
<H3>
  Send a Form from Absolute URL using POST
</H3>
<P>
Request a <CODE>POST</CODE> form referencd by an absolute URL appended with
the formdata given. The URL can <I>NOT</I> contain any fragment identifier!
The list of form data must be given as an association list where the name
is the field name and the value is the value of the field.
<PRE>
extern HTParentAnchor * HTPostFormAbsolute (HTAssocList *	formdata,
					    const char *	base,
					    HTRequest *	request);
</PRE>
<H3>
  Send a Form from a Relative URL using GET
</H3>
<P>
Request a <CODE>POST</CODE> form referencd by a relative URL appended with
the formdata given. The URL can <I>NOT</I> contain any fragment identifier!
The list of form data must be given as an association list where the name
is the field name and the value is the value of the field.
<PRE>
extern HTParentAnchor * HTPostFormRelative (HTAssocList * 	formdata,
					    const char * 	relative,
					    HTParentAnchor *	base,
					    HTRequest *		request);
</PRE>
<H3>
  Send a Form using an Anchor and the POST Method
</H3>
<P>
Request a <CODE>POST</CODE> form referencd by an anchor object appended with
the formdata given. The URL can NOT contain any fragment identifier! The
list of form data must be given as an association list where the name is
the field name and the value is the value of the field.
<PRE>
extern HTParentAnchor * HTPostFormAnchor (HTAssocList *	formdata,
					  HTAnchor *	anchor,
					  HTRequest * 	request);
</PRE>
<H2>
  <A NAME="Head">Get Metainformation about a Document (Method = HEAD)</A>
</H2>
<P>
If you are not interested in the document itself but only in the
<I>metainformation</I> that you can get <I>describing</I> the document then
you should use the <CODE>HEAD</CODE> method in your request.
<H3>
  Get Metainformation about a Document from Absolute URL
</H3>
<P>
Request metainfomration about a document referencd by an <I>absolute</I>
URL.
<PRE>extern BOOL HTHeadAbsolute (const char * url, HTRequest * request);
</PRE>
<H3>
  Get Metainformation about a Document from Relative URL
</H3>
<P>
Request metainformation about a document referenced by a <I>relative</I>
URL.
<PRE>extern BOOL HTHeadRelative (const char * 	relative,
			    HTParentAnchor *	base,
			    HTRequest *		request);
</PRE>
<H3>
  Get Metainformation about a Document using an Anchor
</H3>
<P>
Here the URL is represented by an <A HREF="HTAnchor.html">Anchor object</A>.
You can get an anchor object representing a URL by passing the URL to the
approproiate method in the <A HREF="HTAnchor.html">Anchor class</A>.
<PRE>extern BOOL HTHeadAnchor (HTAnchor * anchor, HTRequest * request);
</PRE>
<H2>
  <A NAME="Delete">Delete a Document (Method = DELETE)</A>
</H2>
<P>
If you want to delete a document (or make the document inaccessible for future
references) then you can use the <CODE>DELETE</CODE> method in your request.
<H3>
  Delete a Document from Absolute URL
</H3>
<P>
Request metainfomration about a document referencd by an <I>absolute</I>
URL.
<PRE>extern BOOL HTDeleteAbsolute (const char * url, HTRequest * request);
</PRE>
<H3>
  Delete a Document from Relative URL
</H3>
<P>
Request metainformation about a document referenced by a <I>relative</I>
URL.
<PRE>extern BOOL HTDeleteRelative (const char * 	relative,
			    HTParentAnchor *	base,
			    HTRequest *		request);
</PRE>
<H3>
  Delete a Document using an Anchor
</H3>
<P>
Here the URL is represented by an <A HREF="HTAnchor.html">Anchor object</A>.
You can get an anchor object representing a URL by passing the URL to the
approproiate method in the <A HREF="HTAnchor.html">Anchor class</A>.
<PRE>extern BOOL HTDeleteAnchor (HTAnchor * anchor, HTRequest * request);
</PRE>
<H2>
  <A NAME="SaveASIS">Save a Document ASIS (Method = PUT)</A>
</H2>
<P>
You can upload a document to a remote server using the following methods.
The document that you want to PUT must be in the form of an anchor. The reason
for this is that when we are put'ing a document we must have some metainformation
available. Metainformation can be the media type, the document length, the
lamguage, or any other metainformation that you can find associated with
the Anchor object.
<P>
This set of functions takes the contents of the anchor <B>ASIS</B> - that
it the <I>exact</I> content of the document associated with this anchor will
be sent to the remote server. If your anchor represents a structured content
and the document itself is a parse tree, for example, then you can use the
more flexible structure <A HREF="HTAccess.html#SaveStructured">PUT interface
below</A>.
<P>
If your application is an Web editor, then you may want to create a new anchor
on the fly for temporary backups on local disk before you save it to a remote
server. An easy way to get a new anchor with a local file URL pointing into
local file space is by using the <A HREF="HTHome.html#temp">HTTmpAnchor()</A>
function which is part of the <A HREF="WWWApp.html">WWWApp interface</A>.
<H3>
  Save a Document ASIS from Absolute URL using PUT
</H3>
<P>
Upload a document referenced by an absolute URL. The URL can <I>NOT</I> contain
any fragment identifier - that is, it must be a parent anchor! The list of
form data must be given as an association list where the name is the field
name and the value is the value of the field.
<PRE>
extern BOOL HTPutAbsolute (HTParentAnchor *	source,
			   const char *		destination,
			   HTRequest *		request);
</PRE>
<H3>
  Save a Document ASIS from Relative URL using PUT
</H3>
<P>
Upload a document referenced by a relative URL appended. The URL can
<I>NOT</I> contain any fragment identifier! The list of form data must be
given as an association list where the name is the field name and the value
is the value of the field.
<PRE>
extern BOOL HTPutRelative (HTParentAnchor *	source,
			   const char * 	relative,
			   HTParentAnchor *	destination_base,
			   HTRequest *		request);
</PRE>
<H3>
  Save a Document ASIS Using an Anchor and the PUT Method
</H3>
<P>
Upload a document referenced by an anchor object appended The URL can
<I>NOT</I> contain any fragment identifier! The list of form data must be
given as an association list where the name is the field name and the value
is the value of the field.
<PRE>
extern BOOL HTPutAnchor (HTParentAnchor *	source,
			 HTAnchor *		dest,
			 HTRequest *	 	request);
</PRE>
<H2>
  <A NAME="SaveStructured">Save a Structured Document (Using PUT)</A>
</H2>
<P>
If the content of the document associated with the anchor contains structured
information and can't be uploaded <B>ASIS</B> then you can use this interface.
The only difference is that the caller must provide the function that provides
data while sending it accross the network. You can find several examples
in the <A HREF="HTAccess.html">HTAccess module</A> on how to write a data
source function. You can for example have a look at the
<CODE>HTEntity_callback</CODE> function which is used in the <B>ASIS</B>
interface.
<H3>
  Save a Structured Document to Absolute URL using PUT
</H3>
<P>
Upload a document referenced by an absolute URL appended. The URL can NOT
contain any fragment identifier! The list of form data must be given as an
association list where the name is the field name and the value is the value
of the field.
<PRE>
extern BOOL HTPutStructuredAbsolute (HTParentAnchor *	source,
				     const char *	destination,
				     HTRequest *	request,
				     HTPostCallback *	input);
</PRE>
<H3>
  Save a Structured Document to Relative URL using PUT
</H3>
<P>
Upload a document referenced by a relative URL appended. The URL can NOT
contain any fragment identifier! The list of form data must be given as an
association list where the name is the field name and the value is the value
of the field.
<PRE>
extern BOOL HTPutStructuredRelative (HTParentAnchor *	source,
				     const char * 	relative,
				     HTParentAnchor *	destination_base,
				     HTRequest *	request,
				     HTPostCallback *	input);
</PRE>
<H3>
  Save a Structured Document Using an Anchor and the PUT Method
</H3>
<P>
Upload a document referenced by an anchor object appended The URL can NOT
contain any fragment identifier! The list of form data must be given as an
association list where the name is the field name and the value is the value
of the field. The HTPostCallback function type is declared in the HTRequest
object.
<PRE>
extern BOOL HTPutStructuredAnchor (HTParentAnchor *	source,
				   HTAnchor *		destination,
				   HTRequest *	 	request,
				   HTPostCallback *	input);
</PRE>
<H2>
  <A NAME="SaveURL">Save a Document (Using PUT)</A>
</H2>
<P>
If the content of the document associated with the anchor contains document
information and can't be uploaded <B>ASIS</B> then you can use this interface.
The only difference is that the caller must provide the function that provides
data while sending it accross the network. You can find several examples
in the <A HREF="HTAccess.html">HTAccess module</A> on how to write a data
source function. You can for example have a look at the
<CODE>HTEntity_callback</CODE> function which is used in the <B>ASIS</B>
interface.
<H3>
  Save a Document from Absolute URL using PUT
</H3>
<P>
Upload a document referenced by an absolute URL appended. The URL can NOT
contain any fragment identifier! The list of form data must be given as an
association list where the name is the field name and the value is the value
of the field.
<PRE>
extern BOOL HTPutDocumentAbsolute (HTParentAnchor *	source,
				   const char *	        destination,
				   HTRequest *	        request);
</PRE>
<H3>
  Save a Document from Relative URL using PUT
</H3>
<P>
Upload a document referenced by a relative URL appended. The URL can NOT
contain any fragment identifier! The list of form data must be given as an
association list where the name is the field name and the value is the value
of the field.
<PRE>
extern BOOL HTPutDocumentRelative (HTParentAnchor *	source,
				   const char * 	relative,
				   HTParentAnchor *	destination_base,
				   HTRequest *          request);
</PRE>
<H3>
  Save a Document Using an Anchor and the PUT Method
</H3>
<P>
Upload a document referenced by an anchor object appended The URL can NOT
contain any fragment identifier! The list of form data must be given as an
association list where the name is the field name and the value is the value
of the field. The HTPostCallback function type is declared in the HTRequest
object.
<PRE>
extern BOOL HTPutDocumentAnchor (HTParentAnchor *	source,
				 HTAnchor *		destination,
				 HTRequest *	 	request);
</PRE>
<H2>
  <A NAME="PostASIS">Save a Document ASIS (Method = POST)</A>
</H2>
<P>
You can upload a document to a remote server using the following methods.
The document that you want to POST must be in the form of an anchor. The
reason for this is that when we are posting a document we must have some
metainformation available. Metainformation can be the media type, the document
length, the lamguage, or any other metainformation that you can find associated
with the Anchor object.
<P>
This set of functions takes the contents of the anchor <B>ASIS</B> - that
it the <I>exact</I> content of the document associated with this anchor will
be sent to the remote server.
<P>
If your application is an Web editor, then you may want to create a new anchor
on the fly for temporary backups on local disk before you save it to a remote
server. An easy way to get a new anchor with a local file URL pointing into
local file space is by using the <A HREF="HTHome.html#temp">HTTmpAnchor()</A>
function which is part of the <A HREF="WWWApp.html">WWWApp interface</A>.
<H3>
  Save a Document ASIS from Absolute URL using POST
</H3>
<P>
Upload a document referenced by an absolute URL. The URL can <I>NOT</I> contain
any fragment identifier - that is, it must be a parent anchor! The list of
form data must be given as an association list where the name is the field
name and the value is the value of the field.
<PRE>
extern BOOL HTPostAbsolute (HTParentAnchor *	source,
			   const char *		destination,
			   HTRequest *		request);
</PRE>
<H3>
  Save a Document ASIS from Relative URL using POST
</H3>
<P>
Upload a document referenced by a relative URL appended. The URL can
<I>NOT</I> contain any fragment identifier! The list of form data must be
given as an association list where the name is the field name and the value
is the value of the field.
<PRE>
extern BOOL HTPostRelative (HTParentAnchor *	source,
			   const char * 	relative,
			   HTParentAnchor *	destination_base,
			   HTRequest *		request);
</PRE>
<H3>
  Save a Document ASIS Using an Anchor and the POST Method
</H3>
<P>
Upload a document referenced by an anchor object appended The URL can
<I>NOT</I> contain any fragment identifier! The list of form data must be
given as an association list where the name is the field name and the value
is the value of the field.
<PRE>
extern BOOL HTPostAnchor (HTParentAnchor *	source,
			 HTAnchor *		dest,
			 HTRequest *	 	request);
</PRE>
<H2>
  Get Available Options for a Document (Method = OPTIONS)
</H2>
<P>
If you want to get information about a document then you can use the the
<CODE>OPTIONS</CODE> method in your request. The <CODE>OPTIONS</CODE> method
represents a request for information about the communication options available
on the request/response chain identified by the <CODE>Request-URI</CODE>.
This method allows the client to determine the options and/or requirements
associated with a resource, or the capabilities of a server, without implying
a resource action or initiating a resource retrieval.
<P>
A speciality about the <CODE>OPTIONS</CODE> method is that the client can
issue a request with no pathinfo at all but only with a "<CODE>*</CODE>".
That is, the request line can look like this "<CODE>OPTIONS * HTTP/1.1</CODE>".
This means that we request information about the server as a whole and not
only about a single URL. You can get this effect by using a URL containing
the hostname alone with <B>NO</B> extra slash at the end, for example
<CODE>http://www.w3.org</CODE>, <CODE>http://www.cern.ch</CODE>.
<H3>
  Options Available for Document from Absolute URL
</H3>
<P>
Request options about a document referencd by an <I>absolute</I> URL.
<PRE>extern BOOL HTOptionsAbsolute (const char * url, HTRequest * request);
</PRE>
<H3>
  Options Available for Document from Relative URL
</H3>
<P>
Request options about a document referenced by a <I>relative</I> URL.
<PRE>extern BOOL HTOptionsRelative (const char * 	relative,
			    HTParentAnchor *	base,
			    HTRequest *		request);
</PRE>
<H3>
  Options Available for Document using an Anchor
</H3>
<P>
Here the URL is represented by an <A HREF="HTAnchor.html">Anchor object</A>.
You can get an anchor object representing a URL by passing the URL to the
appropriate method in the <A HREF="HTAnchor.html">Anchor class</A>.
<PRE>extern BOOL HTOptionsAnchor (HTAnchor * anchor, HTRequest * request);
</PRE>
<H2>
  Get Trace Loop back Information for a Document (Method = TRACE)
</H2>
<P>
The TRACE method is used to invoke a remote, application-layer loop-back
of the request message. The final recipient of the request SHOULD reflect
the message received back to the client as the entity-body of a 200 (OK)
response. The final recipient is either the origin server or the first proxy
or gateway to receive a Max-Forwards value of zero (0) in the request (see
section 14.31). A TRACE request MUST NOT include an entity.
<P>
TRACE allows the client to see what is being received at the other end of
the request chain and use that data for testing or diagnostic information.
The value of the Via header field (section 14.44) is of particular interest,
since it acts as a trace of the request chain. Use of the Max-Forwards header
field allows the client to limit the length of the request chain, which is
useful for testing a chain of proxies forwarding messages in an infinite
loop.
<P>
If successful, the response SHOULD contain the entire request message in
the entity-body, with a Content-Type of <CODE>"message/http"</CODE>. Responses
to this method MUST NOT be cached.
<H3>
  Traces Available for Document from Absolute URL
</H3>
<P>
Request traces about a document referencd by an <I>absolute</I> URL.
<PRE>extern BOOL HTTraceAbsolute (const char * url, HTRequest * request);
</PRE>
<H3>
  Traces Available for Document from Relative URL
</H3>
<P>
Request traces about a document referenced by a <I>relative</I> URL.
<PRE>extern BOOL HTTraceRelative (const char * 	relative,
			     HTParentAnchor *	base,
			     HTRequest *	request);
</PRE>
<H3>
  Traces Available for Document using an Anchor
</H3>
<P>
Here the URL is represented by an <A HREF="HTAnchor.html">Anchor object</A>.
You can get an anchor object representing a URL by passing the URL to the
appropriate method in the <A HREF="HTAnchor.html">Anchor class</A>.
<PRE>extern BOOL HTTraceAnchor (HTAnchor * anchor, HTRequest * request);
</PRE>
<H2>
  Save a URL To Multiple Destinations
</H2>
<P>
<I><B>Note:</B> This is not as stable as the other functions yet!</I>
<P>
These are the generic versions of the <CODE>PUT</CODE> and <CODE>POST</CODE>
functions. They can be used to send documents to multiple destinations
simultanously using the PostWeb model.
<H3>
  Copy an anchor
</H3>
<P>
Fetch the URL from either local file store <B>or</B> from a remote HTTP server
and send it using either PUT or POST to the remote destination using HTTP.
The caller can decide the exact method used and which HTTP header fields
to transmit by setting the user fields in the request structure. If posting
to NNTP then we can't dispatch at this level but must pass the source anchor
to the news module that then takes all the refs to NNTP and puts into the
"newsgroups" header Returns YES if request accepted, else NO
<PRE>extern BOOL HTCopyAnchor (HTAnchor * src_anchor, HTRequest * main_req);
</PRE>
<H3>
  Upload an Anchor
</H3>
<P>
This function can be used to send data along with a request to a remote server.
It can for example be used to POST form data to a remote HTTP server - or
it can be used to post a newsletter to a NNTP server. In either case, you
pass a callback function which the request calls when the remote destination
is ready to accept data. In this callback you get the current request object
and a stream into where you can write data. It is very important that you
return the value returned by this stream to the Library so that it knows
what to do next. The reason is that the outgoing stream might block or an
error may occur and in that case the Library must know about it. If you do
not want to handle the stream interface yourself then you can use the
<CODE>HTUpload_callback</CODE> which is declared below. The source anchor
represents the data object in memory and it points to the destination anchor
by using the <A HREF="../User/Architecture/PostWeb.html">POSTWeb method</A>.
The source anchor contains metainformation about the data object in memory
and the destination anchor represents the reponse from the remote server.
Returns YES if request accepted, else NO
<PRE>extern BOOL HTUploadAnchor (HTAnchor *		source_anchor,
			    HTRequest * 	request,
			    HTPostCallback *	callback);
</PRE>
<H3>
  POST Callback Handler
</H3>
<P>
Is you do not want to handle the stream interface on your own, you can use
this "middleman" function which does the actual writing to the target stream
for the anchor upload and also handles the return value from the stream.
Now, your application is called via the callback function that you may associate
with a request object. You indicate when you have sent all the data you want
by returning HT_LOADED from the callback.
<PRE>
extern int HTUpload_callback (HTRequest * request, HTStream * target);
</PRE>
<PRE>
#endif /* HTACCESS_H */
</PRE>
<P>
  <HR>
<ADDRESS>
  @(#) $Id$
</ADDRESS>
</BODY></HTML>
