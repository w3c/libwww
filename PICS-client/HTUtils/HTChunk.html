<HTML>
<HEAD>
<!-- Changed by: Henrik Frystyk Nielsen, 13-Jul-1996 -->
  <TITLE>W3C Reference Library libwww Chunk Class</TITLE>
</HEAD>
<BODY>
<H1>
  The Chunk Class
</H1>
<PRE>
/*
**	(c) COPYRIGHT MIT 1995.
**	Please first read the full copyright statement in the file COPYRIGH.
*/
</PRE>
<P>
The Chunk Class &nbsp;defines a way to automatically handle dynamic strings
and other data types. You create a chunk with an initial size and it will
then automatically grow to accomodate added data to the chunk. It is a general
utility module. It is garanteed that the array is <CODE>'\0' </CODE>terminated
at all times (and hence is a valid C type string). The method
<A HREF="HTChunk.html#Terminate">HTChunkTerminate</A> can be used to explicitly
add a terminating <CODE>'\0'</CODE> and then to include this character in
the chunk size. If left out, the terminating character is <I>not</I> considered
part of the chunk.
<P>
<B>Note</B>: The names without a "_" (made as a <CODE>#define</CODE>'s) are
only provided for backwards compatibility and should not be used.
<P>
This module is implemented by <A HREF="HTChunk.c">HTChunk.c</A>, and it is
a part of the <A HREF="http://www.w3.org/pub/WWW/Library/"> W3C Reference
Library</A>.
<PRE>
#ifndef HTCHUNK_H
#define HTCHUNK_H

</PRE>
<H2>
  The Chunk Class
</H2>
<P>
This structure should not be referenced outside this module! We only keep
it here to maintain high performance. <B>Don't </B>use it directly!
<PRE>
typedef struct {
	int	size;		/* In bytes			*/
	int	growby;		/* Allocation unit in bytes	*/
	int	allocated;	/* Current size of *data	*/
	char *	data;		/* Pointer to malloced area or 0 */
} HTChunk;
</PRE>
<H2>
  Create new chunk
</H2>
<P>
Create a new chunk and specify the number of bytes to allocate at a time
when the chunk is later extended. Arbitrary but normally a trade-off time
vs. memory
<PRE>
#define HTChunkCreate(growby) HTChunk_new(growby)
extern HTChunk * HTChunk_new (int growby);
</PRE>
<H2>
  Free a chunk
</H2>
<P>
Free a chunk created by <CODE>HTChunkCreate</CODE>from memory
<PRE>
#define HTChunkFree(ch) HTChunk_delete(ch)
extern void HTChunk_delete (HTChunk * ch);
</PRE>
<H2>
  Clear a chunk
</H2>
<P>
Keep the chunk in memory but clear all data kept inside. This can be used
if you know that you can reuse the allocated memory instead of allocating
new memory.
<PRE>
#define HTChunkClear(ch) HTChunk_clear(ch)
extern void HTChunk_clear (HTChunk * ch);
</PRE>
<H2>
  Ensure a Chunk has a Certain Amount of Free Space
</H2>
<P>
Make sure that a chunk has a certain size. If this is not the case then the
chunk is expanded. Nothing is done if the current size if bigger than the
size requested.
<PRE>
#define HTChunkEnsure(ch, s) HTChunk_ensure(ch, s)
extern void HTChunk_ensure (HTChunk * ch, int s);
</PRE>
<H2>
  Append a character to a chunk
</H2>
<P>
Add the character and increment the size of the chunk by one character
<PRE>
#define HTChunkPutc(ch, c) HTChunk_putc(ch, c)
extern void HTChunk_putc (HTChunk * ch, char c);
</PRE>
<H2>
  Append a string to a chunk
</H2>
<P>
Add the string and increment the size of the chunk by the length of the string
(without the trailing zero)
<PRE>
#define HTChunkPuts(ch, str) HTChunk_puts(ch, str)
extern void HTChunk_puts (HTChunk * ch, const char *str);
</PRE>
<H2>
  Append a block to a chunk
</H2>
<P>
Add the block and increment the size of the chunk by the len
<PRE>
extern void HTChunk_putb (HTChunk * ch, const char *block, int len);

</PRE>
<H2>
  Zero Terminate a chunk
</H2>
<P>
As a chunk often is a dynamic string, it needs to be terminated by a zero
in order to be used in C. However, <B>by default</B> any chunk is
<I>always</I> zero terminated, so the only purpose of this function is to
increment the size counter with one corresponding to the zero.
<PRE>
#define HTChunkTerminate(ch)	HTChunk_terminate(ch)
#define HTChunk_terminate(ch)	HTChunk_putc((ch), '\0')
</PRE>
<H2>
  Return Pointer to Data
</H2>
<P>
This define converts a chunk to a normal char pointer so that it can be parsed
to any ANSI C string function.
<PRE>
#define HTChunkData(me)         ((me) ? (me)-&gt;data : NULL)
#define HTChunk_data(me)         ((me) ? (me)-&gt;data : NULL)
</PRE>
<H2>
  CString conversions
</H2>
<P>
A Chunk may be build from an allocated string. The chunk assumes control
of the passes string, elminating the need for additional allocations and
string copies.<BR>
Once a string is built, the chunk may be destroyed and the string kept around.
<PRE>
extern HTChunk * HTChunk_fromCString	(char * str, int grow);
extern char * HTChunk_toCString		(HTChunk * ch);
</PRE>
<H2>
  Return Current Size
</H2>
<P>
Returns the current size of the chunk
<PRE>
#define HTChunkSize(me)         ((me) ? (me)-&gt;size : -1)
#define HTChunk_size(me)         ((me) ? (me)-&gt;size : -1)
</PRE>
<PRE>
#endif
</PRE>
<P>
  <HR>
<ADDRESS>
  @(#) $Id$
</ADDRESS>
</BODY></HTML>
